<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Metodología I</title>
    <meta charset="utf-8" />
    <meta name="author" content=".small[Juan Carlos Castillo    Departamento de Sociología - UCH / COES   ]" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <link href="libs/animate.css/animate.xaringan.css" rel="stylesheet" />
    <script src="libs/fabric/fabric.min.js"></script>
    <link href="libs/xaringanExtra-scribble/scribble.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-scribble/scribble.js"></script>
    <script>document.addEventListener('DOMContentLoaded', function() { window.xeScribble = new Scribble({"pen_color":["#FF0000"],"pen_size":3,"eraser_size":30,"palette":[]}) })</script>
    <link rel="stylesheet" href="../../files/css/custom_2020.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">

class: front









&lt;!---
Para correr en ATOM
- open terminal, abrir R (simplemente, R y enter)
- rmarkdown::render('static/docpres/07_interacciones/7interacciones.Rmd', 'xaringan::moon_reader')

About macros.js: permite escalar las imágenes como [scale 50%](path to image), hay si que grabar ese archivo js en el directorio.
---&gt;


.pull-left[
# Metodología I
## **.yellow[Juan Carlos Castillo]**
## Magister Ciencias Sociales FACSO - UChile
## 1er Sem 2023 
## [.green[metod1-mcs.netlify.com]](https://metod1-mcs.netlify.com)
] 
    

.pull-right[
.right[
&lt;br&gt;
## .yellow[Sesión 4: Introducción inferencia estadística]
![:scale 70%](../../files/img/eval-hires.png)



]

]
---

layout: true
class: animated, fadeIn

---
class: inverse, bottom, right, animated, slideInRight

# Introducción a inferencia


---

.pull-left-narrow[
# Inferencia
]


.pull-right-wide[
¿En qué medida se pueden relacionar resultados que se encuentran en un .green[(sub)conjunto de unidades] con lo que ocurre .red[en general]?]

--

.pull-right-wide[
Ej: si en un subconjunto de la población encuentro que el promedio de matemáticas es mayor en mujeres que en hombres ¿es esto un .orange[reflejo] de lo que ocurre en general, o se debe solo al .red[azar]? ¿se puede .green[extrapolar] a la poblacion?
]

???

mapa y territorio, Borges
lidiando con el caos y la incertidumbre
la domesticación de la casualidad
error

---
# Ejercicio

- tenemos una población de (ej.) 200

- en esta población existen 6 niveles educacionales, homogéneamente distribuidos (cada nivel educacional equivale a a 1/6 de la población)

- por lo tanto, el nivel educacional promedio de la población equivale a 1+2+3+4+5+6/6= 3.5

---
# Ejercicio: Muestra aleatoria

- cada persona selecciona al azar a 5 sujetos (5 dados) y les "pregunta" su nivel educacional (cara superior del dado luego de tirarlo)

- sacar el promedio y desviación estándar de cada muestra

- ¿qué tanto varían los promedios?


---
.pull-left-narrow[

![](https://multivariada.netlify.app/slides/images/inference1.png)
]
.pull-right-wide[

## Conceptos claves de inferencia
- La **inferencia** en estadística se refiere a la relación que existe entre los resultados obtenidos basados en nuestra muestra y la población

{{content}}

]

--

- **¿En qué medida podemos hacer inferencias desde nuestra muestra a la población?**

{{content}}

--

- Un concepto central es la probabilidad de **ERROR**


---
# Parámetros y estadísticos

&lt;br&gt;

|                     	| Población (parámetro)  	| Muestra (estadístico)  	|
|---------------------	|------------------------	|------------------------	|
| Promedio            	|       `\(\mu\)`           	|   `\(\bar{x}\)`           	|
| Varianza            	|        `\(\sigma²\)`      	|  `\(s²\)`                  	|
| Desviación estándar 	|        `\(\sigma\)`        	| `\(s\)`                    	|

---
# Bases de inferencia:

- dispersión: varianza y desviación estandar

- curva normal

- error estándar

---
.pull-left-narrow[
# Dispersión:
## Varianza
]

.pull-right-wide[

![:scale 100%](https://multivariada.netlify.app/slides/02-bases/varianza2.png)
]


---
# Medidas de Dispersión

.pull-left[

## Varianza
&lt;br&gt;

&lt;br&gt;

## Desviación estándar
]

.pull-right[

`$$s^2=\frac{\Sigma(x-\bar{x})²}{N-1}$$`

&lt;br&gt;

`$$s=\sqrt \frac{\Sigma(x-\bar{x})²}{N-1}$$`]

---

.pull-left-narrow[
![](https://multivariada.netlify.app/slides/images/inference1.png)

]

.pull-right-wide[
.content-box-purple[

## Desviación estándar y error estándar]
- más que el promedio de la variable en nuestra **muestra**, en inferencia nos interesa estimar en qué medida ese promedio da cuenta del promedio de la **población**

{{content}}

]

--

- contamos con **una muestra**, pero sabemos que otras muestras podrían haber sido extraídas, probablemente con distintos resultados.

---
# Error estándar

![](https://multivariada.netlify.app/slides/images/se_1.png)
---
# Error estándar

![](https://multivariada.netlify.app/slides/images/se_2.png)
---
# Error estándar

![](https://multivariada.netlify.app/slides/images/se_3.png)
---

# Error estándar

- ¿Cómo calculamos el error estándar a partir de **una** muestra?

- Basados en el **teorema del límite central**, en muestras mayores a 30 la desviación estándar de los promedios (error estándar) equivale a:

`$$\sigma_{\bar{X}}=SE(error estándar)=\frac{s}{\sqrt{N}}$$`
---
class: inverse middle center

# ¿Para qué nos sirve el 
#.red[error estándar]?

---
# Error, rangos y probabilidad


.pull-left-narrow[
.medium[

- Nuestro promedio muestral `\(\bar{x}\)` posee una distribución normal con una desviación estandar = SE (error estándar)

- Esto nos permite calcular una probabilidad de error basados en los valores de la curva normal

]
]
.pull-right-wide[
.center[![:scale 95%](https://multivariada.netlify.app/slides/images/normal.png)]]

---
# Error, rangos y probabilidad


.pull-left[
.center[![:scale 85%](https://multivariada.netlify.app/slides/images/normal.png)]]


.pull-right[
.medium[

- Por ejemplo, `\(\bar{x}\)` +/- 2 SE abarca aproximadamente el 95% de los valores probables

- De otra manera, puedo dar un rango de valores donde se encuentra el promedio(+- 2 SE), con un nivel de confianza de 95%

- ... o con una probabilidad de error p&lt;0.05

]
]

---
class: roja, bottom, right, slideInRight


# Inferencia y diferencia entre promedios


---
class: middle 
.pull-left-narrow[
.content-box-gray[
# .red[¿Es posible traducir preguntas sustantivas a diferencias (de promedios) entre grupos?]
]
]

--

.pull-right-wide[
.right[ 

Gran parte de las preguntas de investigación pueden traducirse a un lenguaje de .red[diferencias entre grupos]
]

&lt;br&gt;

.right[ 
Si las diferencias se refieren a un constructo operacionalizado en forma de .red[variable continua], es posible obtener un promedio, y también promedios para distintos grupos]
]

---
class: inverse center

### En términos de investigación (con pretensión de generalización), no es relevante que dos promedios sean distintos en una .red[muestra], sino en la .yellow[población]

--

### La probabilidad de encontrar diferencias en la población se asocia al concepto de .orange[significación estadística]

---
.pull-left-narrow[
# Inferencia y significación estadística
]

.pull-right-wide[
- ¿Con qué nivel de **probabilidad** estamos dispuest_s a aceptar que las diferencias (entre promedios) son distintas de 0?
]

--

.pull-right-wide[
- Por convención, una probabilidad de error (o valor *p*) de menos de 0.05 (1 de 20 veces)
]

--

.pull-right-wide[
- Esto significa una probabilidad de acierto/nivel de confianza de 95% (2 SE)
]
---

.center[![:scale 70%](https://multivariada.netlify.app/slides/images/inferencia1.png)]


---
class: inverse right bottom

# Inferencia e hipótesis

---
class: middle

.pull-left-narrow[
# Inferencia y prueba de hipótesis
]

.pull-right-wide[
- La hipótesis nula (o `\(H_0\)` ) se refiere a que las diferencias (de promedios) son = 0


- Por eso, queremos rechazar `\(H_0\)` para poder tener evidencia a favor de nuestra hipótesis

- Para eso tenemos que establecer un nivel de probabilidad aceptable (al menos p&lt;0.05)
]

---
## Prueba de hipótesis 

Contrastamos la *hipótesis nula* (no hay diferencias de promedios entre grupos):

`$$H_{0}: \bar{X}_a -  \bar{X}_b= 0$$`

En relación a la siguiente hipótesis alternativa:

`$$H_{a}: \bar{X}_a -  \bar{X}_b \neq 0$$`

---
class: middle

.pull-left-narrow[
# Prueba _t_
]

.pull-right-wide[
- la prueba .red[_t_] nos permite establecer el nivel de error que estamos cometiendo al rechazar `\(H_0\)`

- para ello, .red[_t_] se ajusta por la cantidad de unidades en la muestra (N), pero para un N&gt;120 se aproxima a la distribución normal
]

---
## Inferencia, diferencias y prueba _t_

.medium[
- La prueba _t_ se utiliza para inferencias sobre diferencias de promedios  y básicamente es una razón entre

.center[![:scale 40%](https://multivariada.netlify.app/slides/images/t1.png)]

- Ya que la diferencia esperada si `\(H_0\)` es verdadera es 0, entonces:

`$$t=\frac{\bar{X}_a -  \bar{X}_b}{SE(\bar{X}_a -  \bar{X}_b)}$$`
]


---
# Pasos

1. obtener `\(\bar{X}_a -  \bar{X}_b\)`

2. obtener SE (error estándar) de `\(\bar{X}_a -  \bar{X}_b\)`

3.  calcular t: `\(t=\frac{\bar{X}_a -  \bar{X}_b}{SE(\bar{X}_a -  \bar{X}_b)}\)`

4. determinar la probabilidad de error asociada al valor t

---
## `\(SE(\bar{X}_a -  \bar{X}_b)\)`

- Ej: para el caso simple de una variable dicotómica:

`$$SE=\sqrt{\frac{\sigma_{diff}}{n_a}+\frac{\sigma_{diff}}{n_b}}$$`

- Para lo cual se requiere calcular la desviación estandar de la diferencia:

`$$\sigma_{diff}=\frac{\sigma^2_{a}(n_a-1)+\sigma^2_{b}(n_b-1)}{n_a+n_b-2}$$`

---
# ¿Cómo utilizamos el valor _t_ ?

- T ( `\(\bar{X}_a -  \bar{X}_b/SE_{\bar{X}_a -  \bar{X}_b}\)` ) se compara con un  **valor crítico**

- El valor crítico se obtiene de una tabla según el nivel de probabilidad de error `\(\alpha\)` y los **grados de libertad** N-k-1 (siendo k el número de diferencias de promedios - o predictores presentes en un modelo)

- Si nuestro T observado &gt; valor crítico de T, entonces rechazamos `\(H_0\)` al nivel de confianza establecido

---
# Valor crítico de T

Imaginemos que nuestro `\(t=\frac{\bar{X}_a -  \bar{X}_b}{SE}=\frac{10}{4}=2.5\)`

a) Nivel de confianza 95%

b) N= 300 y una diferencia de promedios (k=1)

En consecuencia tenemos un `\(\alpha = 0.05\)` y `\(gl = 300 -1 - 1 = 298\)`

---

.pull-left[
# Valor crítico de T y "colas" de la curva
.middle[
![:scale 120%](https://multivariada.netlify.app/slides/07-inferencia/imagen4.png)
]]

.pull-right[
- con el valor crítico de t se busca detectar diferencias en ambos sentidos (positivas y negativas)

- por lo tanto, el nivel de confianza definido se divide en 2 al momento de contrastar con el valor crítico 

- ej: para un nivel de confianza `\(\alpha=0.5\)`, queda en 0.25

]


---
# Valor crítico de T
.medium[
.pull-left[
- Para un 95% de confianza 
    - `\(\alpha\)` =0.05
    - 0.025 dos colas 
    - valor crítico = 1- `\(\alpha\)` = 0.975
    
-  y grados de libertad 298, se busca en alguna [tabla de valores críticos de T](https://people.richland.edu/james/lecture/m170/tbl-t.html) ... o directamente en R:
]

.pull-right[


```r
qt(0.975, 298)
```

```
## [1] 1.967957
```

- Nuestro T (2.5) es mayor que el T crítico (1.96), por lo tanto podemos rechazar `\(H_0\)` con un 95% de confianza ... o con una probabilidad de error p&lt;0.05 ]
]
---
# Valor crítico de T

Lo mismo pero para un `\(\alpha=0.01\)` que equivale a un percentil = 0.995 (dos colas)


```r
qt(0.995, 297)
```

```
## [1] 2.592484
```

En este caso, no podemos rechazar `\(H_0\)` con un 99% de confianza.

---
# Valor crítico de T

- para simplificar, básicamente se utilizan 2 valores críticos de T / Z: 
  - 1.96 para un `\(\alpha=0.05\)`
  - 2.58 para un `\(\alpha=0.01\)`

- por lo tanto, si el la diferencia de promedios se divide por el error estándar y da más que **1.96**, entonces es estadísitcamente significativo con una probabilidad de error **p &lt;0.05**, y si es mayor de **2.58** es estadísitcamente significativo con una probabilidad de error **p &lt;0.01**

---
class: inverse

.right[## .red[Resumen: inferencia de diferencias de promedios]
]
- conceptos centrales: error estándar de `\(\bar{X}_a -  \bar{X}_b\)` y **valor T**

- el valor T se obtiene dividiendo la diferencia de promedios por el error estándar de esta misma diferencia

- para muestras grandes, un T &gt; 1.96 permite rechazar `\(H_0\)` con una probabilidad de error p&lt;0.05, y T &gt; 2.58 con una probabilidad de error p&lt;0.01

---


class: front

.pull-left[
# Metodología I
## **.yellow[Juan Carlos Castillo]**
## Magister Ciencias Sociales FACSO - UChile
## 1er Sem 2023 
## [.green[metod1-mcs.netlify.com]](https://metod1-mcs.netlify.com)
] 
    

.pull-right[
.right[
&lt;br&gt;
## .yellow[Sesión 4: Introducción inferencia estadística]
![:scale 70%](../../files/img/eval-hires.png)



]

]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="https://multinivel.netlify.com/docpres/xaringan_custom/macros.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
.logo {
  background-image: url("../hex_multiva_white.png");
  background-size: contain;
  background-repeat: no-repeat;
  position: absolute;
  top: 16.3em;
  right: 31em;
  width: 110px;
  height: 70px;
  z-index: 0;
}
</style>

<script>
document
  .querySelectorAll(
    '.remark-slide-content' +
    ':not(.title-slide)' +
    // add additional classes to exclude here, e.g.
    // ':not(.inverse)' +
    ':not(.hide-logo)'
  )
  .forEach(el => {
    el.innerHTML += '<div class="logo"></div>';
  });
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
